/*
** Copyright (c) 2017, Thomas Farr
**
** This Source Code Form is subject to the terms of the Mozilla Public
** License, v. 2.0. If a copy of the MPL was not distributed with this
** file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

#include <algorithm>
#include <cstdint>
#include <args.hxx>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <regex>
#include <string>
#include <string_view>

constexpr int32_t DEFAULT_ALIGNMENT = 4;
constexpr int32_t DEFAULT_BYTES_PER_LINE = 16;

struct PositiveIntReader {
  auto operator()(const std::string &name, const std::string &value,
                  int32_t &destination) const -> bool {
    std::istringstream str_stream(value);
    str_stream >> destination;

    if (str_stream.rdbuf()->in_avail() > 0 || destination < 1) {
      std::ostringstream problem{};
      problem << "Argument '" << name << "' must be a positive int, received '"
              << value << "'";
      throw args::ParseError(problem.str());
    }

    return true;
  }
};

struct PO2IntReader {
  auto operator()(const std::string &name, const std::string &value,
                  int32_t &destination) const -> bool {
    std::istringstream str_stream(value);
    str_stream >> destination;

    if (str_stream.rdbuf()->in_avail() > 0 || destination < 1 ||
        (destination & (destination - 1)) != 0) {
      std::ostringstream problem{};
      problem << "Argument '" << name << "' must be a power of two, received '"
              << value << "'";
      throw args::ParseError(problem.str());
    }

    return true;
  }
};

auto basename(const std::string &path) -> std::string {
#if defined(WIN32) || defined(_WIN32)
  static constexpr auto path_seps = "/\\";
#else
  static constexpr auto path_seps = "/";
#endif

  std::string_view view(path);
  const auto last_non_path_sep = view.find_last_not_of(path_seps);
  if (last_non_path_sep == std::string_view::npos) {
    return {};
  }
  view = view.substr(0, last_non_path_sep + 1);

  if (const auto last_path_sep = view.find_last_of(path_seps);
      last_path_sep != std::string_view::npos) {
    view = view.substr(last_path_sep + 1);
  }

  return std::string(view);
}

auto make_c_identifier(const std::string &str) -> std::string {
  static std::regex invalidChar("[^A-Za-z0-9_./-]");
  static std::regex separatorChar("[./-]");
  static std::regex leadingDigit("^(\\d)");

  auto res = std::regex_replace(str, invalidChar, "");
  res = std::regex_replace(res, separatorChar, "_");
  return std::regex_replace(res, leadingDigit, "_$1");
}

enum class result : uint8_t {
  success,
  identifier_invalid,
  read_error,
  empty_stream
};

auto bin2s(const std::string &identifier, std::istream &input,
           std::ostream &output, const int32_t alignment = DEFAULT_ALIGNMENT,
           const int32_t lineLength = DEFAULT_BYTES_PER_LINE) -> result {
  const auto c_identifier = make_c_identifier(identifier);

  if (c_identifier.empty()) {
    return result::identifier_invalid;
  }

  const auto cur_pos = input.tellg();
  input.seekg(0, std::ios::end);
  const std::streamsize size = input.tellg() - cur_pos;
  input.seekg(cur_pos);

  if (size == 0) {
    return result::empty_stream;
  }

  input.get();
  if (!input) {
    return result::read_error;
  }
  input.seekg(-1, std::ios::cur);

  output << "  .section .rodata\n"
         << "  .balign " << alignment << '\n'
         << "  .global " << c_identifier << '\n'
         << "  .global " << c_identifier << "_end\n"
         << "  .global " << c_identifier << "_size\n"
         << '\n'
         << c_identifier << ":\n";

  std::streamsize nRead(0);
  std::vector<uint8_t> readBytes(lineLength);

  for (auto remaining = size; remaining > 0; remaining -= nRead) {
    input.read(reinterpret_cast<char *>(readBytes.data()), // NOLINT(*-pro-type-reinterpret-cast)
               std::min(static_cast<std::streamsize>(lineLength), remaining));
    nRead = input.gcount();

    if (!input) {
      return result::read_error;
    }

    output << "  .byte ";

    for (std::streamsize index = 0; index < nRead; ++index) {
      output << std::setw(3) << static_cast<uint16_t>(readBytes[index]);
      if (index < nRead - 1) {
        output << ',';
      }
    }

    output << '\n';
  }

  output << '\n'
         << c_identifier << "_end:\n"
         << '\n'
         << "  .align\n"
         << c_identifier << "_size: .int " << size << '\n';

  return result::success;
}

auto bin2s_files(const std::vector<std::string> &files, std::ostream &output,
                 const int32_t alignment = DEFAULT_ALIGNMENT,
                 const int32_t lineLength = DEFAULT_BYTES_PER_LINE) -> int {
  output << "/* Generated by BIN2S - please don't edit directly */\n";

  for (const auto &file : files) {
    std::ifstream input(file, std::ios::binary);

    if (!input) {
      std::cerr << "bin2s: error: could not open  \"" << file << "\"\n";
      return 1;
    }

    const auto ret =
        bin2s(basename(file), input, output, alignment, lineLength);
    input.close();

    switch (ret) {
    case result::success:
      break;
    case result::identifier_invalid:
      std::cerr
          << "bin2s: error: filename does not contain any valid characters \""
          << file << "\"\n";
      return 1;
    case result::read_error:
      std::cerr << "bin2s: error: unable to read file \"" << file << "\"\n";
      return 1;
    case result::empty_stream:
      std::cerr << "bin2s: warning: skipping empty file \"" << file << "\"\n";
      break;
    }
  }

  return 0;
}

auto main(int argc, char *argv[]) -> int {
  args::ArgumentParser parser("Convert binary files to GCC assembly modules.");
  static constexpr auto extended_description = R"__(
For each input file it will output assembly defining:

  * {identifier}:
      An array of bytes containing the data.
  * {identifier}_end:
      Will be at the location directly after the end of the data.
  * {identifier}_size:
      An unsigned int containing the length of the data in bytes.

Roughly equivalent to this pseudocode:

  unsigned int identifier_size = ...
  unsigned char identifier[identifier_size] = { ... }
  unsigned char identifier_end[] = identifier + identifier_size

Where {identifier} is the input file's name,
sanitized to produce a legal C identifier, by doing the following:

  * Stripping all character that are not ASCII letters, digits or one of _-./
  * Replacing all of -./ with _
  * Prepending _ if the remaining identifier begins with a digit.

e.g. for gfx/foo.bin {identifier} will be foo_bin,
     and for 4bit.chr it will be _4bit_chr.
)__";
  parser.SetArgumentSeparations(false, true, true, true);
  args::HelpFlag helpFlag(parser, "HELP", "Show this help message and exit",
                          {'h', "help"});
  args::ValueFlag<int32_t, PO2IntReader> alignmentFlag(
      parser, "ALIGNMENT", "Boundary alignment, in bytes [default: 4]",
      {'a', "alignment"}, DEFAULT_ALIGNMENT);
  args::ValueFlag<int32_t, PositiveIntReader> lineLengthFlag(
      parser, "LINE_LENGTH",
      "Number of bytes to output per line of ASM [default: 16]",
      {'l', "line-length"}, DEFAULT_BYTES_PER_LINE);
  args::ValueFlag<std::string> outputFlag(
      parser, "OUTPUT", "Output file, \"-\" represents stdout [default: -]",
      {'o', "output"}, "-");
  args::PositionalList<std::string> filesList(
      parser, "FILES", "Binary file to convert to GCC assembly");

  try {
    parser.ParseCLI(argc, argv);
  } catch (args::Help &) {
    std::cout << parser << extended_description;
    return 0;
  } catch (args::ParseError &e) {
    std::cerr << "ERROR: " << e.what() << "\n\n"
              << parser << extended_description;
    return 1;
  }

  auto alignment = args::get(alignmentFlag);
  auto lineLength = args::get(lineLengthFlag);
  const auto &outputFile = args::get(outputFlag);
  const auto &inputFiles = args::get(filesList);

  if (inputFiles.empty()) {
    return 0;
  }

  if (outputFile == "-") {
    return bin2s_files(inputFiles, std::cout, alignment, lineLength);
  }

  std::ofstream output(outputFile);
  if (!output) {
    std::cerr << "bin2s: error: could not open output file \"" << outputFile
              << '"' << '\n';
    return 1;
  }
  auto ret = bin2s_files(inputFiles, output, alignment, lineLength);
  output.close();
  return ret;
}
